
R version 3.4.1 (2017-06-30) -- "Single Candle"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> #### Header ####
> 
> # Program created to pull data from CRSP/Compustat to use for building an neural
> # network that can identify the stocks that will have the highest decile of alpha
> # next period and the lowest decile of alpha to construct a long-short portfolio
> #
> # Created:
> #   Date - Mar. 31, 2017
> #   R Version - 3.3.3 (RStudio Version 1.0.136)
> # Last Modified:
> #   Date - Mar. 31, 2017
> #   R Version - 3.3.3 (RStudio Version 1.0.136)
> 
> 
> #### Sources ####
>   # Increase Java max heap size to 12 GB
>   options(java.parameters = "-Xmx64g")
>   # Increase warning length to max allowed so if SQL statements produce error it will all print
>   options(warning.length = 8170)
>   library("wrdsr")
>   library("dplyr") 
>   library("readr")
>   library("tibble")
>   library("indclass")
>   library("lubridate")
>   library("zoo")
> 
> #### Establish connection to WRDS ####
> 
>   wrds_db <- wrdsConnect("jestover", "mkQ2NiG86D$UuUw@U$0l", librefs = "wrdssec '/wrds/sec/sasdata'", conn = "postgresql")
>   local_db <- src_sqlite(path.expand("/home/jandres/data/monthly-momentum-financial-data.sqlite"), create = T)
> 
> ##### Pull data from CRSP Monthly Securities and CRSP/Compustat Merged #####
>   
>   # Merging Compustat values with CRSP 3 months after the end of the fiscal year to make sure it is after the data is available to the market
>   
>   sql <- "SELECT ccm.gvkey AS gvkey,
+                  dsf.permno AS permno,
+                  dsf.date AS date,
+                  dsf.prc AS price,
+                  dsf.bidlo AS low,
+                  dsf.askhi AS high,
+                  dsf.ret AS return,
+                  dsf.vol AS volume
+           FROM crspa.dsf AS dsf
+           INNER JOIN crsp.ccmxpf_lnkhist AS ccm
+             ON dsf.permno = ccm.lpermno
+           INNER JOIN crspa.dsfhdr AS hdr
+             ON dsf.permno = hdr.permno
+           WHERE dsf.date >= ccm.linkdt
+             AND (dsf.date <= ccm.linkenddt OR ccm.linkenddt IS NULL)
+             AND ccm.linktype IN ('LC', 'LU', 'LS')
+             AND ccm.linkprim IN ('C', 'P')
+             AND hdr.hshrcd IN (10, 11)
+             AND EXTRACT (year FROM date) >= 1977
+             ORDER BY ccm.gvkey, dsf.date"
>   # Fetch the desired data
>   results <- dbSendQuery(wrds_db, sql)
>   crsp <- as_data_frame(dbFetch(results))
>  
>   # Find gvkeys with no missing data (except return, since first obs often lacks
>   # return) 
>   gvkeys <- crsp %>%
+     group_by(gvkey) %>%
+     summarize(price = sum(is.na(price)),
+               low = sum(is.na(low)),
+               high = sum(is.na(high)),
+               return = sum(is.na(return)),
+               volume = sum(is.na(volume))) %>%
+     filter(price == 0, low == 0, high == 0, return <= 1, volume == 0) %>%
+     .[["gvkey"]]
>   
>   # Filter data to include only gvkeys with complete data
>   # Also, clean data 
>   ## Take abs value of price, low, and high, since negative sign just means that
>   ## there was no closing volume, and a bid / ask average was used instead
>   crsp <- crsp %>%
+     filter(gvkey %in% gvkeys) %>%
+     mutate(price = abs(price),
+            low = abs(low),
+            high = abs(high),
+            date = as.Date(date),
+            range = (high - low) / ((high + low) / 2)) %>%
+     select(-high, -low)
>   
>   #db_drop_table(local_db$con, "crsp") 
>   copy_to(local_db, crsp, temporary = FALSE,
+           indexes = list(c("gvkey", "date"), "date"))
>   rm(crsp)
>   gc()
          used (Mb) gc trigger   (Mb)   max used   (Mb)
Ncells  719044 38.5    1168576   62.5    1168576   62.5
Vcells 1067353  8.2  945411843 7213.0 1164863039 8887.2
>   
>   sql <- "SELECT comp.gvkey AS gvkey,
+                  comp.conm AS comp_name,
+                  date(comp.datadate + INTERVAL '3 month') AS start_date,
+                  date(comp.datadate + INTERVAL '15 month' - INTERVAL '1 day') AS end_date,
+                  b.sic AS sic,
+                  comp.atq AS assets, 
+                  comp.revtq AS revenue,
+                  comp.niq AS net_income,
+                  comp.cshoq AS number_shares,
+                  comp.ceqq AS equity,
+                  comp.ltq AS liabilities
+           FROM compm.fundq AS comp
+           LEFT JOIN compm.company AS b 
+             ON comp.gvkey = b.gvkey
+           WHERE INDFMT = 'INDL'
+             AND CONSOL = 'C'
+             AND DATAFMT = 'STD'
+             AND EXTRACT (year FROM datadate) >= 1976"
>   # Fetch the desired data
>   results <- dbSendQuery(wrds_db, sql)
>   comp <- as_data_frame(dbFetch(results))
>   
>   # fill in missing values for other columns, by leaving initial and trailing 
>   # NA's as NA and interpolating interior NA's, i.e.
>   # c(NA, 9, 3, NA, 3, NA, 5, NA, NA, 2, NA) becomes c(NA, 9, 3, 3, 3, 4, 5, 4, 3, 2, NA)
>   comp <- comp %>%
+     group_by(gvkey) %>%
+     mutate(assets = na.approx(assets, na.rm = FALSE),
+            revenue = na.approx(revenue, na.rm = FALSE),
+            net_income = na.approx(net_income, na.rm = FALSE),
+            number_shares = na.approx(number_shares, na.rm = FALSE),
+            equity = na.approx(equity, na.rm = FALSE),
+            liabilities = na.approx(liabilities, na.rm = FALSE)) %>%
+     filter(!is.na(assets), !is.na(revenue), !is.na(net_income), !is.na(number_shares),
+            !is.na(equity), !is.na(liabilities), !is.na(sic)) %>%
+     ungroup()
>   
>   # Store data in SQLite database to make easier to access in future
>   #db_drop_table(local_db$con, "comp") 
>   copy_to(local_db, comp, temporary = FALSE,
+           indexes = list(c("gvkey", "start_date"), "start_date", "end_date"))
>   rm(comp)
>   gc()
          used (Mb) gc trigger   (Mb)   max used   (Mb)
Ncells  723512 38.7    1442291   77.1    1442291   77.1
Vcells 1080965  8.3  247834041 1890.9 1164863039 8887.2
>   
>   sql <- "SELECT comp.gvkey AS gvkey,
+                  date,
+                  comp_name,
+                  sic,
+                  price,
+                  low,
+                  high,
+                  return,
+                  volume,
+                  assets,
+                  revenue,
+                  net_income,
+                  number_shares,
+                  equity,
+                  liabilities
+           FROM crsp
+           INNER JOIN comp
+             ON comp.gvkey = crsp.gvkey
+           WHERE date >= start_date 
+             AND date <= end_date"
>   # Fetch the desired data
>   results <- dbSendQuery(local_db, sql)
